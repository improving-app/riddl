type MemberId is Id(ImprovingApp.MembersContext.Member)
  briefly "Unique identifier for Tenant Entity"

type MemberMap is mapping from MemberId to MembersContext.Info

context MembersContext  is {
    type PublicMemberEvent is one of {
        MemberRegistered,
        MemberActivated,
        MemberSuspended,
        MemberTerminated,
        MemberInfoEdited,
        MemberData
    }

    source MemberEvents is {
        outlet Events is type PublicMemberEvent
    } explained as "This is a source for Organization Events"

    //Member Details
    type MemberStatuses is any of {Active, Suspended} briefly "Internal status of an Organization."

    type NotificationPreference is any of { Email, SMS, Application } described
    as {
      | The values of this enumeration define the ways in which a member may
      | be notified of changes.
    }

    type RequiredDraftInfo is {
        contact: Contact
          briefly "Contact information of the member",
        handle: String
          briefly "username. Must be unique.",
        avatar: URL
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String
          briefly "Real first name of the member",
        lastName: String
          briefly "Real last name of the member",
        tenant: TenantId
          briefly "Tenant id of the member"
    } described as {
      |This type provides the basic information about members that is
      |required for transitioning to Established state. The fields of this type form the profile
      |of the Member with demographics, contact info, and various options
      |like notifications and group membership the Member can opt in to.
    }

    type OptionalDraftInfo is {
        notificationPreference: NotificationPreference?
            briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
            briefly "A possibly empty list of organizations this member belongs to."
    }

    type Info is {
        contact: Contact
          briefly "Contact information of the member",
        handle: String
          briefly "username. Must be unique.",
        avatar: URL
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String
          briefly "Real first name of the member",
        lastName: String
          briefly "Real last name of the member",
        //mobileNumber: MobileNumber? briefly "Optional mobile phone number",
        //emailAddress: EmailAddress? briefly "Optional email address",
        notificationPreference: NotificationPreference?
          briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
          briefly "A possibly empty list of organizations this member belongs to.",
        tenant: TenantId
          briefly "Tenant id of the member"
    } described as {
      |This type provides the basic information about members that is
      |retained by the Member entity. The fields of this type form the profile
      |of the Member with demographics, contact info, and various options
      |like notifications and group membership the Member can opt in to.
    }
    type EditInfo is {
        handle: String?
          briefly "username. Must be unique.",
        avatar: URL?
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String?
          briefly "Real first name of the member",
        lastName: String?
          briefly "Real last name of the member",
        //mobileNumber: MobileNumber?,
        //emailAddress: EmailAddress?,
        notificationPreference: NotificationPreference?
          briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
          briefly "A list of organizations this member belongs to.",
        tenant: TenantId*
          briefly "the tenant(s) this Member would belong to"
    } described as {
      |This aggregate type specifies a way to update any or all of the
      |MemberInfo fields. If a field value is missing (they are all optional)
      |then the current value is not updated.
    }
    type MetaInfo is {
        createdOn: TimeStamp
          briefly "The timestamp the member was created",
        createdBy: MemberId
          briefly "The member that created this member",
        lastModifiedOn: TimeStamp
          briefly "The timestamp the member was last modified",
        lastModifiedBy: MemberId
          briefly "The member that last modified this member"
    }
    type MetaInfoQuery is {
        createdOn: TimeStamp?
          briefly "Optionally the timestamp to match a member's creation timestamp against",
        createdBy: MemberId?
          briefly "Optionally the member id to match a member's creator against",
        lastModifiedOn: TimeStamp?
          briefly "Optionally the timestamp to match a member's last modification timestamp against",
        lastModifiedBy: MemberId?
          briefly "Optionally the member id to match a member's last modifier against"
    }

    command RegisterMember is {
      memberId: MemberId briefly "Unique identifier for the new member",
      info: MembersContext.Info briefly "Info needed for registration",
      registeringMember: MemberId briefly "Member that registered new member"
    } briefly "Create a single new member"
      described as {
       |RegisterMember creates a single new member. The member can be
       |registered by either another member or by themselves. As this
       |could be a self-service request the OrganizationType is optional.
    }

    event MemberRegistered is {
      memberId: MemberId briefly "Unique identifier for the registered member",
      info: MembersContext.Info briefly "Info describing the member",
      meta: MembersContext.MetaInfo
    } briefly "Event issued after RegisterMember or RegisterMemberList"
    described as {
      |This event occurs whenever a member is registered and provides the
      |meta information for the registered member.  In the case of
      |RegisterMemberList one event per member in the list is published.
    }

    //command RegisterMemberList is {
    //  memberList: MemberMap,
    //  registeringMember: MemberId
    //} briefly "Create a bunch of members"
    //described as {
    //  |RegisterMemberList creates multiple members with a single call. The
    //  |limitation is you can only define a single MemberType in each call, and
    //  |all new Members must be assigned to the same Organization (typically a
    //  |BaseOrg).
    //}

    //event MemberListRegistered is {
    //  memberList: MemberMap,
    //  registeringMember: MemberId
    //}

    command EditMemberInfo is {memberId: MemberId, info: MembersContext.EditInfo, actingMember: MemberId}
    briefly "Edit info of a member"
    described as {
      |This command will overwrite the values of attributes provided in UpdateInfo.
      |If an attribute is not referenced it will be left as is. If an attribute is
      |referenced with no value, an empty value will replace what is currently
      |stored. If an attribute is referenced with a value, the new value will
      |overwrite what is stored.
    }

    event MemberInfoEdited is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    briefly "Event issued after EditMemberInfo"
    described as {
      |This event occurs whenever a member's information is edited.
    }

    command ActivateMember is {memberId: MemberId, actingMember: MemberId}
    briefly "Update state of member to Active"
    described as {
      |This command activates the member.
    }

    event MemberActivated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after ActivateMember"
    described as {
      |This event is issued after ActivateMember to denote
      |that the member is now active.
    }


    command SuspendMember is {memberId: MemberId, suspendingMember: MemberId}
    briefly "Update state of member to Suspended"
    described as {
      |This command suspends the member such that most operations are not available.
    }

    event MemberSuspended is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after SuspendMember"
    described as {
      |This event is issued after SuspendMember to denote
      |that the member is now suspended.
    }

    command TerminateMember is {memberId: MemberId, actingMember: MemberId}
    briefly "Update state of member to Terminated"
    described as {
      |This command terminates the member.
    }

    event MemberTerminated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after TerminateMember"
    described as {
      |This event is issued after TerminateMember to denote
      |that the member is now terminated.
    }

    query GetMemberData is {memberId: MemberId}
    briefly "Get the data of a member"
    described as {
      |This query gets the data of a member if it exists.
    }

    result MemberData is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    briefly "The data of the member returned from the GetMemberData query"
    described as {
      |This result contains the member id, member information, and member metadata.
    }

    query GetMembersByMetaInfo is {queryData: MembersContext.MetaInfoQuery}
    briefly "Get the members based on the meta info"
    described as {
      |This query gets the members by checking if at least one of the fields of
      |MetaInfoQuery has matched.
    }

    result MemberListResult is {members: MemberMap}
    briefly "The data returned from the GetMembersByMetaInfo query"
    described as {
      |This result contains the MemberMap, which contains all members that
      |matched to at least one of the fields of MetaInfoQuery.
    }

    entity Member is {
        options(aggregate, technology("akka"))

        handler MemberHandler is {
            on command RegisterMember {
                then send event MemberRegistered(
                    memberId = @RegisterMember.memberId,
                    info = @RegisterMember.info,
                    meta = !MembersContext.MetaInfo(
                        createdOn = now(),
                        createdBy = @RegisterMember.registeringMember,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @RegisterMember.registeringMember,
                        currentState = @MemberStates.Draft
                    )
                ) to outlet MemberEvents.Events
                and morph entity Member to state DraftMember with !DraftMemberState(
                    requiredInfo = !MembersContext.RequiredDraftInfo(
                        contact = @RegisterMember.info,
                        handle = @RegisterMember.info,
                        avatar = @RegisterMember.info,
                        firstName = @RegisterMember.info,
                        lastName = @RegisterMember.info,
                        tenant = @RegisterMember.info
                    ),
                    optionalInfo = !OrganizationContext.OptionalDraftInfo(
                        notificationPreference = @RegisterMember.info,
                        organizationMembership = @RegisterMember.info
                    ),
                    meta = !MembersContext.MetaInfo(
                        createdOn = now(),
                        createdBy = @RegisterMember.registeringMember,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @RegisterMember.registeringMember,
                        currentState = @OrganizationStates.Draft
                    )
                )
            }
            //on command RegisterMemberList {
            //    //TODO: list operations on the following:
            //    then morph entity Member to state Member.Active
            //      with record ^^ActiveState(info = MembersContext.Info(),
            //        meta = MembersContext.MetaInfo())
            //    //TODO: How do you reference members of a mapping?
            //    //and set Active.memberId to @RegisterMemberList.MemberList.memberId
            //    //and set Active.info to @RegisterMemberList.MemberList.info
            //}
        }

        record DraftMemberState is {
          requiredInfo: MembersContext.RequiredDraftInfo,
          optionalInfo: MembersContext.OptionalDraftInfo,
          meta: MembersContext.MetaInfo
        }
        state DraftMember of DraftMemberState is {
          handler DraftMemberHandler {
            on command RegisterMember {then error "Member has already been registered."}
            on command ActivateMember {
              given "entity has non-empty required fields"
              then "morph Member entity to Active state"
              and "set entity lastModifiedBy to actingMember from message"
              and "set entity lastModifiedOn to today()"
              and "yield event MemberActivated"
            }
            on command TerminateMember {
              given "entity has non-empty required fields"
              then "morph Member entity to Terminated state"
              and "set entity lastModifiedBy to actingMember from message"
              and "set entity lastModifiedOn to today()"
              and "yield event MemberTerminated"
            }
            on command EditMemberInfo {
              then "set entity Info to non-Empty fields in UpdateInfo from message"
              and "set entity lastModifiedBy to actingMember from message"
              and "set entity lastModifiedOn to today()"
              and "yield event MemberInfoUpdated"
            }
            // For GetMemberData, eventually probably only admins and self should be able to make this call. Also
            // potentially allow other roles to get some limited information (this will require adding another
            // aggregate).
            on query GetMemberData {
              then "yield Info for entity"
            }
          }
        } described as {
          |This state is the initial state of a Member. It describes that the member
          |is not yet ready to be active. Once out of this state, a member cannot go
          |back to Draft.
        }

        record RegisteredMemberState is {
            info: MembersContext.Info,
            meta: MembersContext.MetaInfo
        }
        state RegisteredMember of RegisteredMemberState is {
            invariant time_sanity is {
              <=(@RegisteredMemberState.meta, @RegisteredMemberState.meta)
            }
            invariant firstName is {
              >=(length(@RegisteredMemberState.info.firstName), 3)
            }
            invariant lastName is {
              >=(length(@RegisteredMemberState.info.firstName), 3)
            }

/*
                    handle: String briefly "username. Must be unique.",
                    avatar: URL briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
                    firstName: String,
                    lastName: String,
                    mobileNumber: MobileNumber?,
                    emailAddress: EmailAddress?,
                    notificationPreference: NotificationPreference?
                      briefly "if this is set it is assumed that the user has opted in.",
                    organizationMembership: OrganizationId*
                      briefly "A list of organizations this member belongs to."
*/

            handler ActiveMemberHandler {
                on command RegisterMember {then error "Member has already been registered."}
                on command EditMemberInfo {
                    then "set entity Info to non-Empty fields in UpdateInfo from message"
                    and "set entity lastModifiedBy to actingMember from message"
                    and "set entity lastModifiedOn to today()"
                    and "yield event MemberInfoUpdated"
                }
                on command SuspendMember {
                    then become entity Organization to handler SuspendedOrganizationHandler
                    and "update the meta info to reflect the change"
                    and "yield event OrganizationSuspended"
                }
                on command TerminateMember {
                    then "update the meta info to reflect the change"
                    and morph entity Member to state TerminatedMember with !TerminatedMemberState(lastMeta = @RegisteredMemberState.meta)
                }
                on query GetMemberData {
                    then "yield Info for entity"
                }
            }
            handler SuspendedMemberHandler {
                on command RegisterMember {then error "Member has already been registered."}
                on command ActivateMember {
                  given "entity has non-empty required fields"
                  then "morph Member entity to Active state"
                  and "set entity lastModifiedBy to actingMember from message"
                  and "set entity lastModifiedOn to today()"
                  and "yield event MemberActivated"
                }
                on command SuspendMember {
                  given "entity has suspensionReason non-empty"
                  then "morph Member entity to Active state"
                  and "set entity lastModifiedBy to actingMember from message"
                  and "set entity lastModifiedOn to today()"
                  and "yield event MemberSuspended"
                } briefly "A suspension reason can be updated by re-issuing the command"
                on command TerminateMember {
                  given "entity has non-empty required fields"
                  then "morph Member entity to Terminated state"
                  and "set entity lastModifiedBy to actingMember from message"
                  and "set entity lastModifiedOn to today()"
                  and "yield event MemberTerminated"
                }
                on query GetMemberData {
                  then "yield Info for entity"
                }
              } described as {
              |This state describes that a member cannot access anything due
              |to being a bad actor. This state transition is only possible
              |as a command issued by an administrator and therefore can only
              |be removed from the suspended state by an administrator.
            }
        } described as {
          |This state describes that a member is now active. An active
          |member can transition to any state other than Draft.
        }

        record TerminatedMemberState is {
            lastMeta: MembersContext.MetaInfo
        }
        state TerminatedMember of TerminatedMemberState is {
            handler TerminatedMemberHandler is {
                on other { then error "Terminated members cannot process messages" }
            }
        } described as {
          |This state describes a member who exercises their right to be forgotten.
        }

    } described in file "member-entity.md"
} described in file "members-context.md"
