
context MembersContext is {
    type MemberId is Id(^MembersContext.Member)
      briefly "Unique identifier for Tenant Entity"

    type PublicMemberEvent is one of {
        MemberRegistered,
        MemberActivated,
        MemberSuspended,
        MemberTerminated,
        MemberInfoEdited,
        MemberData
    }
    source MemberEvents is {
        outlet Events is type PublicMemberEvent
    } explained as "This is a source for Organization Events"

    type MemberMap is mapping from MembersContext.MemberId to MembersContext.Info

    //Member Details
    type MemberStates is any of {Draft, Active, Suspended} briefly "Internal status of an Organization."

    type NotificationPreference is any of { Email, SMS, Application } described
    as {
      | The values of this enumeration define the ways in which a member may
      | be notified of changes.
    }

    type RequiredDraftInfo is {
        contact: Contact
          briefly "Contact information of the member",
        handle: String
          briefly "username. Must be unique.",
        avatar: URL
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String
          briefly "Real first name of the member",
        lastName: String
          briefly "Real last name of the member",
        tenant: TenantId
          briefly "Tenant id of the member"
    } described as {
      |This type provides the basic information about members that is
      |required for transitioning to Established state. The fields of this type form the profile
      |of the Member with demographics, contact info, and various options
      |like notifications and group membership the Member can opt in to.
    }

    type OptionalDraftInfo is {
        notificationPreference: NotificationPreference?
            briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
            briefly "A possibly empty list of organizations this member belongs to."
    }

    type Info is {
        contact: Contact
          briefly "Contact information of the member",
        handle: String
          briefly "username. Must be unique.",
        avatar: URL
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String
          briefly "Real first name of the member",
        lastName: String
          briefly "Real last name of the member",
        //mobileNumber: MobileNumber? briefly "Optional mobile phone number",
        //emailAddress: EmailAddress? briefly "Optional email address",
        notificationPreference: NotificationPreference?
          briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
          briefly "A possibly empty list of organizations this member belongs to.",
        tenant: TenantId
          briefly "Tenant id of the member"
    } described as {
      |This type provides the basic information about members that is
      |retained by the Member entity. The fields of this type form the profile
      |of the Member with demographics, contact info, and various options
      |like notifications and group membership the Member can opt in to.
    }
    type EditableInfo is {
        handle: String?
          briefly "username. Must be unique.",
        avatar: URL?
          briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String?
          briefly "Real first name of the member",
        lastName: String?
          briefly "Real last name of the member",
        //mobileNumber: MobileNumber?,
        //emailAddress: EmailAddress?,
        notificationPreference: NotificationPreference?
          briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId*
          briefly "A list of organizations this member belongs to.",
        tenant: TenantId*
          briefly "the tenant(s) this Member would belong to"
    } described as {
      |This aggregate type specifies a way to update any or all of the
      |MemberInfo fields. If a field value is missing (they are all optional)
      |then the current value is not updated.
    }
    type MetaInfo is {
        createdOn: TimeStamp
          briefly "The timestamp the member was created",
        createdBy: MembersContext.MemberId
          briefly "The member that created this member",
        lastModifiedOn: TimeStamp
          briefly "The timestamp the member was last modified",
        lastModifiedBy: MembersContext.MemberId
          briefly "The member that last modified this member"
    }
    type MetaInfoQuery is {
        createdOn: TimeStamp?
          briefly "Optionally the timestamp to match a member's creation timestamp against",
        createdBy: MembersContext.MemberId?
          briefly "Optionally the member id to match a member's creator against",
        lastModifiedOn: TimeStamp?
          briefly "Optionally the timestamp to match a member's last modification timestamp against",
        lastModifiedBy: MembersContext.MemberId?
          briefly "Optionally the member id to match a member's last modifier against"
    }

    command RegisterMember is {
      memberId: MemberId briefly "Unique identifier for the new member",
      info: MembersContext.Info briefly "Info needed for registration",
      registeringMember: MemberId briefly "Member that registered new member"
    } briefly "Create a single new member"
      described as {
       |RegisterMember creates a single new member. The member can be
       |registered by either another member or by themselves. As this
       |could be a self-service request the OrganizationType is optional.
    }

    event MemberRegistered is {
      memberId: MemberId briefly "Unique identifier for the registered member",
      info: MembersContext.Info briefly "Info describing the member",
      meta: MembersContext.MetaInfo
    } briefly "Event issued after RegisterMember or RegisterMemberList"
    described as {
      |This event occurs whenever a member is registered and provides the
      |meta information for the registered member.  In the case of
      |RegisterMemberList one event per member in the list is published.
    }

    // TODO: DO we still want this? Needs to be discussed, not sure why it was taken out - Alex
    //command RegisterMemberList is {
    //  memberList: MemberMap,
    //  registeringMember: MemberId
    //} briefly "Create a bunch of members"
    //described as {
    //  |RegisterMemberList creates multiple members with a single call. The
    //  |limitation is you can only define a single MemberType in each call, and
    //  |all new Members must be assigned to the same Organization (typically a
    //  |BaseOrg).
    //}

    //event MemberListRegistered is {
    //  memberList: MemberMap,
    //  registeringMember: MemberId
    //}

    command EditMemberInfo is {memberId: MemberId, info: MembersContext.EditableInfo, editingMember: MemberId}
    briefly "Edit info of a member"
    described as {
      |This command will overwrite the values of attributes provided in UpdateInfo.
      |If an attribute is not referenced it will be left as is. If an attribute is
      |referenced with no value, an empty value will replace what is currently
      |stored. If an attribute is referenced with a value, the new value will
      |overwrite what is stored.
    }

    event MemberInfoEdited is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    briefly "Event issued after EditMemberInfo"
    described as {
      |This event occurs whenever a member's information is edited.
    }

    command ActivateMember is {memberId: MemberId, activatingMember: MemberId}
    briefly "Update state of member to Active"
    described as {
      |This command activates the member.
    }

    event MemberActivated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after ActivateMember"
    described as {
      |This event is issued after ActivateMember to denote
      |that the member is now active.
    }


    command SuspendMember is {memberId: MemberId, suspendingMember: MemberId}
    briefly "Update state of member to Suspended"
    described as {
      |This command suspends the member such that most operations are not available.
    }

    event MemberSuspended is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after SuspendMember"
    described as {
      |This event is issued after SuspendMember to denote
      |that the member is now suspended.
    }

    command TerminateMember is {memberId: MemberId, terminatingMember: MemberId}
    briefly "Update state of member to Terminated"
    described as {
      |This command terminates the member.
    }

    event MemberTerminated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    briefly "Event issued after TerminateMember"
    described as {
      |This event is issued after TerminateMember to denote
      |that the member is now terminated.
    }

    query GetMemberData is {memberId: MemberId}
    briefly "Get the data of a member"
    described as {
      |This query gets the data of a member if it exists.
    }

    result MemberData is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    briefly "The data of the member returned from the GetMemberData query"
    described as {
      |This result contains the member id, member information, and member metadata.
    }

    query GetMembersByMetaInfo is {queryData: MembersContext.MetaInfoQuery}
    briefly "Get the members based on the meta info"
    described as {
      |This query gets the members by checking if at least one of the fields of
      |MetaInfoQuery has matched.
    }

    result MemberListResult is {members: MemberMap}
    briefly "The data returned from the GetMembersByMetaInfo query"
    described as {
      |This result contains the MemberMap, which contains all members that
      |matched to at least one of the fields of MetaInfoQuery.
    }

    entity Member is {
        options(aggregate, technology("akka"))

        handler MemberHandler is {
            on command RegisterMember {
                then send event MemberRegistered(
                    memberId = @RegisterMember.memberId,
                    info = @RegisterMember.info,
                    meta = !MembersContext.MetaInfo(
                        createdOn = now(),
                        createdBy = @RegisterMember.registeringMember,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @RegisterMember.registeringMember,
                        currentState = @MemberStates.Draft
                    )
                ) to outlet MemberEvents.Events
                and morph entity Member to state DraftMember with !DraftMemberState(
                    requiredInfo = !MembersContext.RequiredDraftInfo(
                        contact = @RegisterMember.info,
                        handle = @RegisterMember.info,
                        avatar = @RegisterMember.info,
                        firstName = @RegisterMember.info,
                        lastName = @RegisterMember.info,
                        tenant = @RegisterMember.info
                    ),
                    optionalInfo = !OrganizationContext.OptionalDraftInfo(
                        notificationPreference = @RegisterMember.info,
                        organizationMembership = @RegisterMember.info
                    ),
                    meta = !MembersContext.MetaInfo(
                        createdOn = now(),
                        createdBy = @RegisterMember.registeringMember,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @RegisterMember.registeringMember,
                        currentState = @OrganizationStates.Draft
                    )
                )
            }
            //on command RegisterMemberList {
            //    //TODO: list operations on the following:
            //    then morph entity Member to state Member.Active
            //      with record ^^ActiveState(info = MembersContext.Info(),
            //        meta = MembersContext.MetaInfo())
            //    //TODO: How do you reference members of a mapping?
            //    //and set Active.memberId to @RegisterMemberList.MemberList.memberId
            //    //and set Active.info to @RegisterMemberList.MemberList.info
            //}
        }

        record DraftMemberState is {
          id: MemberId,
          requiredInfo: MembersContext.RequiredDraftInfo,
          optionalInfo: MembersContext.OptionalDraftInfo,
          meta: MembersContext.MetaInfo
        }
        state DraftMember of DraftMemberState is {
          handler DraftMemberHandler {
            on command RegisterMember {then error "Member has already been registered."}
            on command ActivateMember {
              example Success {
                  when "all required fields in requiredInfo are not None or Empty"
                  then send event MemberRegistered(
                      memberId = @DraftMemberState.id,
                      info = !MembersContext.Info(
                         contact = @DraftMemberState.requiredInfo,
                         handle = @DraftMemberState.requiredInfo,
                         avatar = @DraftMemberState.requiredInfo,
                         firstName = @DraftMemberState.requiredInfo,
                         lastName = @DraftMemberState.requiredInfo,
                         notificationPreference = @DraftMemberState.optionalInfo,
                         organizationMembership = @DraftMemberState.optionalInfo,
                         tenant = @DraftMemberState.requiredInfo
                      ),
                      meta = !MembersContext.MetaInfo(
                          createdOn = @DraftMemberState.meta,
                          createdBy = @DraftMemberState.meta,
                          lastUpdatedOn = now(),
                          lastUpdatedBy = @EditOrganizationInfo.editingMember,
                          currentState = @OrganizationStates.Active
                      )
                  ) to outlet MemberEvents.Events
                  and morph entity Member to state RegisteredMember
                      with !RegisteredMemberState(
                          info = !MembersContext.Info(
                              contact = @DraftMemberState.requiredInfo,
                              handle = @DraftMemberState.requiredInfo,
                              avatar = @DraftMemberState.requiredInfo,
                              firstName = @DraftMemberState.requiredInfo,
                              lastName = @DraftMemberState.requiredInfo,
                              notificationPreference = @DraftMemberState.optionalInfo,
                              organizationMembership = @DraftMemberState.optionalInfo,
                              tenant = @DraftMemberState.requiredInfo
                          ),
                          orgMeta = @DraftMemberState.meta
                      )
              }
              example NotSufficient {
                  when "all required fields in state are not present"
                  then error "state is not sufficiently filled out to activate organization"
              }
            }
            on command EditMemberInfo {
              then set DraftMemberState.requiredInfo to !MembersContext.RequiredDraftInfo(
                   contact = @EditMemberInfo.info,
                   handle = @EditMemberInfo.info,
                   avatar = @EditMemberInfo.info,
                   firstName = @EditMemberInfo.info,
                   lastName = @EditMemberInfo.info,
                   tenant = @EditMemberInfo.info
               )
              and set DraftMemberState.optionalInfo to !MembersContext.OptionalDraftInfo(
                   notificationPreference = @EditMemberInfo.info,
                   organizationMembership = @EditMemberInfo.info
              )
              and set DraftMemberState.meta to !MembersContext.MetaInfo(
                  createdOn = @DraftMemberState.meta,
                  createdBy = @DraftMemberState.meta,
                  lastUpdatedOn = now(),
                  lastUpdatedBy = @EditMemberInfo.editingMember,
                  currentState = @MemberStates.Draft
              )
              and send event MemberInfoEdited(
                  memberId = @DraftMemberState.id,
                  info = !MembersContext.Info(
                      contact = @DraftMemberState.requiredInfo,
                      handle = @DraftMemberState.requiredInfo,
                      avatar = @DraftMemberState.requiredInfo,
                      firstName = @DraftMemberState.requiredInfo,
                      lastName = @DraftMemberState.requiredInfo,
                      notificationPreference = @DraftMemberState.optionalInfo,
                      organizationMembership = @DraftMemberState.optionalInfo,
                      tenant = @DraftMemberState.requiredInfo
                  ),
                  meta = @DraftMemberState.meta
              ) to outlet MemberEvents.Events
            }
            // For GetMemberData, eventually probably only admins and self should be able to make this call. Also
            // potentially allow other roles to get some limited information (this will require adding another
            // aggregate).
            on query GetMemberData {
              then "yield Info for entity"
            }
          }
        } described as {
          |This state is the initial state of a Member. It describes that the member
          |is not yet ready to be active. Once out of this state, a member cannot go
          |back to Draft.
        }

        record RegisteredMemberState is {
            id: MemberId,
            info: MembersContext.Info,
            meta: MembersContext.MetaInfo
        }
        state RegisteredMember of RegisteredMemberState is {
            invariant time_sanity is {
              <=(@RegisteredMemberState.meta, @RegisteredMemberState.meta)
            }
            invariant firstName is {
              >=(length(@RegisteredMemberState.info.firstName), 3)
            }
            invariant lastName is {
              >=(length(@RegisteredMemberState.info.firstName), 3)
            }

            handler ActiveMemberHandler {
                on command RegisterMember {then error "Member has already been registered."}
                on command EditMemberInfo {
                    then set RegisteredMemberState.info to !MembersContext.Info(
                       contact = @EditMemberInfo.info,
                       handle = @EditMemberInfo.info,
                       avatar = @EditMemberInfo.info,
                       firstName = @EditMemberInfo.info,
                       lastName = @EditMemberInfo.info,
                       notificationPreference = @EditMemberInfo.info,
                       organizationMembership = @EditMemberInfo.info,
                       tenant = @EditMemberInfo.info
                    )
                    and set RegisteredMemberState.meta to !MembersContext.MetaInfo(
                        createdOn = @RegisteredMemberState.meta,
                        createdBy = @RegisteredMemberState.meta,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @EditMemberInfo.editingMember,
                        currentState = @MemberStates.Draft
                    )
                    and send event MemberInfoEdited(
                        memberId = @DraftMemberState.id,
                        info = !MembersContext.Info(
                            contact = @RegisteredMemberState.info,
                            handle = @RegisteredMemberState.info,
                            avatar = @RegisteredMemberState.info,
                            firstName = @RegisteredMemberState.info,
                            lastName = @RegisteredMemberState.info,
                            notificationPreference = @RegisteredMemberState.info,
                            organizationMembership = @RegisteredMemberState.info,
                            tenant = @RegisteredMemberState.info
                        ),
                        meta = @RegisteredMemberState.meta
                    ) to outlet MemberEvents.Events
                }
                on command SuspendMember {
                    example Success {
                        when "all required fields in requiredInfo are not None or Empty"
                        then send event MemberSuspended(
                            memberId = @RegisteredMemberState.id,
                            info = @RegisteredMemberState.info,
                            meta = !MembersContext.MetaInfo(
                                createdOn = @RegisteredMemberState.meta,
                                createdBy = @RegisteredMemberState.meta,
                                lastUpdatedOn = now(),
                                lastUpdatedBy = @SuspendMember.suspendingMember,
                                currentState = @MemberStates.Suspended
                            )
                        ) to outlet MemberEvents.Events
                        and morph entity Member to state RegisteredMember
                            with !RegisteredMemberState(
                                info = @RegisteredMemberState.info,
                                meta = !MembersContext.MetaInfo(
                                    createdOn = @RegisteredMemberState.meta,
                                    createdBy = @RegisteredMemberState.meta,
                                    lastUpdatedOn = now(),
                                    lastUpdatedBy = @SuspendMember.suspendingMember,
                                    currentState = @MemberStates.Suspended
                                )
                            )
                    }
                }
                on command TerminateMember {
                    then set RegisteredMemberState.meta to !MembersContext.MetaInfo(
                        createdOn = @RegisteredMemberState.meta,
                        createdBy = @RegisteredMemberState.meta,
                        lastUpdatedOn = now(),
                        lastUpdatedBy = @TerminateMember.terminatingMember,
                        currentState = @RegisteredMemberState.meta
                    )
                    and morph entity Member to state TerminatedMember with !TerminatedMemberState(lastMeta = @RegisteredMemberState.meta)
                }
                on query GetMemberData {
                    then "yield Info for entity"
                }
            }
            handler SuspendedMemberHandler {
                on command RegisterMember {then error "Member has already been registered."}
                on command ActivateMember {
                   example Success {
                      then send event MemberActivated(
                          memberId = @RegisteredMemberState.id,
                          info = @RegisteredMemberState.info,
                          meta = !MembersContext.MetaInfo(
                              createdOn = @RegisteredMemberState.meta,
                              createdBy = @RegisteredMemberState.meta,
                              lastUpdatedOn = now(),
                              lastUpdatedBy = @ActivateMember.activatingMember,
                              currentState = @MemberStates.Active
                          )
                      ) to outlet MemberEvents.Events
                      and morph entity Member to state RegisteredMember
                          with !RegisteredMemberState(
                              info = @RegisteredMemberState.info,
                              meta = !MembersContext.MetaInfo(
                                  createdOn = @RegisteredMemberState.meta,
                                  createdBy = @RegisteredMemberState.meta,
                                  lastUpdatedOn = now(),
                                  lastUpdatedBy = @ActivateMember.activatingMember,
                                  currentState = @MemberStates.Active
                              )
                          )
                   }
                }
                on command SuspendMember {
                   then set RegisteredMemberState.meta to !MembersContext.MetaInfo(
                       createdOn = @RegisteredMemberState.meta,
                       createdBy = @RegisteredMemberState.meta,
                       lastUpdatedOn = now(),
                       lastUpdatedBy = @SuspendMember.suspendingMember,
                       currentState = @MemberStates.Suspended
                   )
                   and send event MemberSuspended(
                       memberId = @RegisteredMemberState.id,
                       info = @RegisteredMemberState.info,
                       meta = !MembersContext.MetaInfo(
                           createdOn = @RegisteredMemberState.meta,
                           createdBy = @RegisteredMemberState.meta,
                           lastUpdatedOn = now(),
                           lastUpdatedBy = @SuspendMember.suspendingMember,
                           currentState = @MemberStates.Suspended
                       )
                   ) to outlet MemberEvents.Events
                } briefly "A suspension reason can be updated by re-issuing the command"
                on command TerminateMember {
                  then set RegisteredMemberState.meta to !MembersContext.MetaInfo(
                      createdOn = @RegisteredMemberState.meta,
                      createdBy = @RegisteredMemberState.meta,
                      lastUpdatedOn = now(),
                      lastUpdatedBy = @TerminateMember.terminatingMember,
                      currentState = @RegisteredMemberState.meta
                  )
                  and morph entity Member to state TerminatedMember with !TerminatedMemberState(lastMeta = @RegisteredMemberState.meta)
                }
                on query GetMemberData {
                  then "yield Info for entity"
                }
              } described as {
              |This state describes that a member cannot access anything due
              |to being a bad actor. This state transition is only possible
              |as a command issued by an administrator and therefore can only
              |be removed from the suspended state by an administrator.
            }
        } described as {
          |This state describes that a member is now active. An active
          |member can transition to any state other than Draft.
        }

        record TerminatedMemberState is {
            lastMeta: MembersContext.MetaInfo
        }
        state TerminatedMember of TerminatedMemberState is {
            handler TerminatedMemberHandler is {
                on other { then error "Terminated members cannot process messages" }
            }
        } described as {
          |This state describes a member who exercises their right to be forgotten.
        }

    } described in file "member-entity.md"
} described in file "members-context.md"
