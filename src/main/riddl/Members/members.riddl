context MembersContext is {
    //Member Details
    //type MemberType is any of {Student, FacultyStaff, Vendor, Sponsor, General, Alumni, Parent, Fan}
    type MemberMap is mapping from MemberId to MembersContext.Info //gateway definition
    type NotificationPreference is any of { Email, SMS }
    type Status is any of { Active, Suspended }
    type Info is {
        handle: String briefly "username. Must be unique.",
        avatar: URL briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String,
        lastName: String,
        mobileNumber: MobileNumber?,
        emailAddress: EmailAddress?,
        notificationPreference: NotificationPreference? briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId* briefly "A list of organizations this member belongs to."
        //memberType: MemberType+
    }
    type UpdateInfo is {
        handle: String? briefly "username. Must be unique.",
        avatar: URL? briefly "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String?,
        lastName: String?,
        mobileNumber: MobileNumber?,
        emailAddress: EmailAddress?,
        notificationPreference: NotificationPreference? briefly "if this is set it is assumed that the user has opted in.",
        organizationMembership: OrganizationId* briefly "A list of organizations this member belongs to."
        //memberType: MemberType+
    }
    type MetaInfo is {
        createdOn: Date,
        createdBy: MemberId,
        lastModifiedOn: Date,
        lastModifiedBy: MemberId,
        memberStatus: MembersContext.Status
    }
    type MetaInfoQuery is {
        createdOn: Date?,
        createdBy: MemberId?,
        lastModifiedOn: Date?,
        lastModifiedBy: MemberId?,
        memberStatus: MembersContext.Status?
    }

    command RegisterMember is {memberId: MemberId, info: MembersContext.Info, registeringMember: MemberId} briefly "RegisterMember creates a single new member. As this could be a self-service request the OrganizationType is optional."
    event  MemberRegistered is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo} briefly "Event issued after either RegisterMember or RegisterMemberList is called. In the case of RegisterMemberList one event per member in the list is published."
    command RegisterMemberList is {memberList: MemberMap, registeringMember: MemberId} briefly "RegisterMemberList creates multiple members with a single call. The limitation is you can only define a single MemberType in each call, and all new Members must be assigned to the same Organization (typically a BaseOrg)."
    event MemberListRegistered is {memberList: MemberMap, registeringMember: MemberId}
    command UpdateMemberInfo is {memberId: MemberId, info: MembersContext.UpdateInfo, actingMember: MemberId} briefly "This command will overwrite the values of attributes provided in UpdateInfo. If an attribute is not referenced it will be left as is. If an attribute is referenced with no value, an empty value will replace what is currently stored. If an attribute is referenced with a value, the new value will overwrite what is stored."
    event MemberInfoUpdated is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    command UpdateMemberStatus is {memberId: MemberId, actingMember: MemberId, newStatus: MembersContext.Status}
    event MemberStatusUpdated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    query GetMemberData is {memberId: MemberId}
    result MemberData is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    query GetMembersByMetaInfo is {queryData: MembersContext.MetaInfoQuery}
    result MemberListResult is {members: MemberMap}

    entity Member is {
        option is aggregate

        handler MemberHandler is {
            on command RegisterMember {
                then morph entity Member to state Member.Active
                and set Member.Active.memberId to @RegisterMember.memberId
                and set Member.Active.info to @RegisterMember.info
            }
            on command RegisterMemberList {
                //TODO: list operations on the following:
                then morph entity Member to state Member.Active
                //TODO: How do you reference members of a mapping?
                //and set Active.memberId to @RegisterMemberList.MemberList.memberId
                //and set Active.info to @RegisterMemberList.MemberList.info
            }
        }

        state Active is {
            fields {
                memberId: MemberId,
                info: MembersContext.Info,
                meta: MembersContext.MetaInfo
            }
            handler ActiveMemberHandler {
                on command UpdateMemberInfo {
                    then set ^^.Active.info to @UpdateMemberInfo.info
                    and set ^^.Active.meta.lastModifiedBy to @UpdateMemberInfo.actingMember
                    and set ^^.Active.meta.lastModifiedOn to today()
                    and yield event MemberInfoUpdated(memberId = @Active.memberId, info = @Active.memberInfo, meta = @Active.memberMeta)
                }
                on command UpdateMemberStatus {
                    then set Active.meta.memberStatus to @UpdateMemberStatus.newStatus
                    and set Active.meta.lastModifiedBy to @UpdateMemberInfo.actingMember
                    and set Active.meta.lastModifiedOn to today()
                    and yield event MemberStatusUpdated(memberId = @Active.memberId, meta = @Active.memberMeta)
                }
                on query GetMemberData {  ??? }
            }
        }


        state Terminated is {
            fields {
                memberId: MemberId
            }
            handler TerminatedMemberHandler is {
                on other { then error "Terminated members cannot process messages" }
            }
        } //A terminated member is one who exercises their right to be forgotten.

    }
}
