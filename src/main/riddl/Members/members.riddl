context MembersContext is {
    //Member Details
    //type MemberType is any of {Student, FacultyStaff, Vendor, Sponsor, General, Alumni, Parent, Fan}
    type MemberMap is mapping from MemberId to MembersContext.Info //gateway definition
    type NotificationPreference is any of { Email, SMS }
    type Status is any of { Active, Suspended }
    type Info is {
        handle: String described by "username. Must be unique.",
        avatar: URL described by "thumbnail image of the user. Need to screen to ensure community guidelines compliance. i.e. no porn or offensive content. Use Gravitar?",
        firstName: String,
        lastName: String,
        mobileNumber: MobileNumber?,
        emailAddress: EmailAddress?,
        notificationPreference: NotificationPreference? described by "if this is set it is assumed that the user has opted in."
        //memberType: MemberType+
    }
    type MetaInfo is {
        createdOn: Date,
        createdBy: MemberId,
        lastModifiedOn: Date,
        lastModifiedBy: MemberId, 
        memberStatus: MembersContext.Status
    }
    type MetaInfoQuery is {
        createdOn: Date?,
        createdBy: MemberId?,
        lastModifiedOn: Date?,
        lastModifiedBy: MemberId?, 
        memberStatus: MembersContext.Status?
    }

    command RegisterMember is {memberId: MemberId, info: MembersContext.Info, registeringMember: MemberId} briefly "RegisterMember creates a single new member. As this could be a self-service request the OrganizationType is optional."
    event  MemberRegistered is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo} briefly "Event issued after either RegisterMember or RegisterMemberList is called. In the case of RegisterMemberList one event per member in the list is published."
    command RegisterMemberList is {memberList: MemberMap, registeringMember: MemberId} briefly "RegisterMemberList creates multiple members with a single call. The limitation is you can only define a single MemberType in each call, and all new Members must be assigned to an Organization (typically a BaseOrg)."
    event MemberListRegistered is {memberList: MemberMap, registeringMember: MemberId}
    command UpdateMemberInfo is {memberId: MemberId, info: MembersContext.Info, actingMember: MemberId} briefly "All member info will be overwritten as provided in this command. Best practice would be to retrieve current values first and modify attributes that you desire to change and submit the full MemberInfo object back."
    event MemberInfoUpdated is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    command UpdateMemberStatus is {memberId: MemberId, actingMember: MemberId, newStatus: MembersContext.Status}
    event MemberStatusUpdated is {memberId: MemberId, meta: MembersContext.MetaInfo}
    query GetMemberData is {memberId: MemberId}
    result MemberData is {memberId: MemberId, info: MembersContext.Info, meta: MembersContext.MetaInfo}
    query GetMembersByMetaInfo is {queryData: MembersContext.MetaInfoQuery}
    result MemberListResult is {members: MemberMap}

    entity Member is {
        option is aggregate

        handler MemberHandler is {
            on command RegisterMember {
                then morph entity Member to state Member.Active
                and set Active.memberId to @RegisterMember.memberId
                and set Active.info to @RegisterMember.info
            }
            on command RegisterMemberList {
                //TODO: list operations on the following:
                then morph entity Member to state Member.Active
                //TODO: How do you reference members of a mapping?
                //and set Active.memberId to @RegisterMemberList.MemberList.memberId
                //and set Active.info to @RegisterMemberList.MemberList.info
            }
        }

        state Active is {
            fields {
                memberId: MemberId,
                info: MembersContext.Info,
                meta: MembersContext.MetaInfo
            }
            handler ActiveMemberHandler {
                on command UpdateMemberInfo {
                    then set Active.info to @UpdateMemberInfo.info 
                    and set ^^Active.meta.lastModifiedBy to @UpdateMemberInfo.actingMember
                    and set ^^Active.meta.lastModifiedOn to today()
                    and yield event MemberInfoUpdated(memberId = @Active.memberId, info = @Active.memberInfo, meta = @Active.memberMeta)
                }
                on command UpdateMemberStatus {
                    then set ^^Active.meta.memberStatus to @UpdateMemberStatus.newStatus
                    and set ^^Active.meta.lastModifiedBy to @UpdateMemberInfo.actingMember
                    and set ^^Active.meta.lastModifiedOn to today()
                    and yield event MemberStatusUpdated(memberId = @Active.memberId, meta = @Active.memberMeta)
                }
                on query GetMemberData {  ??? }
            }
        } 
        

        state Terminated is { 
            fields {
                memberId: MemberId
            }
            handler TerminatedMemberHandler is {
                on other { then error "Terminated members cannot process messages" }
            }
        } //A terminated member is one who exercises their right to be forgotten.
        
    }
}